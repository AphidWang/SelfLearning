import { create } from 'zustand';
import { supabase } from '../services/supabase';
import type { Goal, ReferenceInfo, ReferenceAttachment, ReferenceLink } from '../types/goal';

interface GoalStoreState {
  goals: Record<string, Goal>;
  error?: string;
  
  // ÁµÑÂêàÊü•Ë©¢ÊñπÊ≥ï
  getGoalsForTopic: (topicId: string) => Goal[];
  getGoalById: (goalId: string) => Goal | undefined;
  getAllGoals: () => Goal[];
  
  // Goal CRUD Êìç‰Ωú
  addGoal: (topicId: string, goalData: Omit<Goal, 'id' | 'topic_id' | 'version' | 'created_at' | 'updated_at' | 'creator_id'>) => Promise<Goal | null>;
  updateGoal: (goalId: string, expectedVersion: number, updates: Partial<Goal>) => Promise<Goal | null>;
  deleteGoal: (goalId: string) => Promise<boolean>;
  restoreGoal: (goalId: string) => Promise<boolean>;
  updateGoalHelp: (goalId: string, needHelp: boolean, helpMessage?: string) => Promise<boolean>;
  updateGoalReferenceInfo: (goalId: string, referenceInfo: ReferenceInfo) => Promise<boolean>;
  addGoalAttachment: (goalId: string, attachment: Omit<ReferenceAttachment, 'id' | 'created_at'>) => Promise<boolean>;
  removeGoalAttachment: (goalId: string, attachmentId: string) => Promise<boolean>;
  addGoalLink: (goalId: string, link: Omit<ReferenceLink, 'id' | 'created_at'>) => Promise<boolean>;
  removeGoalLink: (goalId: string, linkId: string) => Promise<boolean>;
  setGoalOwner: (goalId: string, userId: string) => Promise<Goal | null>;
  addGoalCollaborator: (goalId: string, userId: string) => Promise<boolean>;
  removeGoalCollaborator: (goalId: string, userId: string) => Promise<boolean>;
  
  // Batch operations for performance
  setGoals: (goals: Goal[]) => void;
  clearGoals: () => void;
}

export const useGoalStore = create<GoalStoreState>((set, get) => ({
  goals: {},
  error: undefined,

  // ÁµÑÂêàÊü•Ë©¢ÊñπÊ≥ï
  getGoalsForTopic: (topicId: string) => {
    const state = get();
    return Object.values(state.goals).filter(goal => goal.topic_id === topicId);
  },
  
  getGoalById: (goalId: string) => {
    const state = get();
    return state.goals[goalId];
  },
  
  getAllGoals: () => {
    const state = get();
    return Object.values(state.goals);
  },

  // Batch operations
  setGoals: (goals: Goal[]) => {
    set(state => {
      const goalsMap = { ...state.goals };
      goals.forEach(goal => {
        goalsMap[goal.id] = goal;
      });
      return { goals: goalsMap };
    });
  },

  clearGoals: () => {
    set({ goals: {} });
  },

  /**
   * Ê∑ªÂä†ÁõÆÊ®ô
   */
  addGoal: async (topicId, goalData) => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Áî®Êà∂Êú™Ë™çË≠â');

      const goalDataWithDefaults = {
        title: goalData.title,
        description: goalData.description || '',
        status: goalData.status || 'todo',
        priority: goalData.priority || 'medium',
        order_index: goalData.order_index || 0,
        need_help: goalData.need_help || false,
        topic_id: topicId,
        creator_id: user.id
      };

      const { data, error } = await supabase
        .from('goals')
        .insert([goalDataWithDefaults])
        .select()
        .single();

      if (error) throw error;

      set(state => ({
        goals: { ...state.goals, [data.id]: data }
      }));
      return data;
    } catch (error: any) {
      console.error('Ê∑ªÂä†ÁõÆÊ®ôÂ§±Êïó:', error);
      set({ error: error.message || 'Ê∑ªÂä†ÁõÆÊ®ôÂ§±Êïó' });
      return null;
    }
  },

  /**
   * Êõ¥Êñ∞ÁõÆÊ®ôÔºàÂ∏∂ÁâàÊú¨ÊéßÂà∂Ôºâ
   */
  updateGoal: async (goalId, expectedVersion, updates) => {
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Áî®Êà∂Êú™Ë™çË≠â');

      const { data, error } = await supabase.rpc('safe_update_goal', {
        p_id: goalId,
        p_expected_version: expectedVersion,
        p_user_id: user.id,
        p_title: updates.title,
        p_description: updates.description,
        p_status: updates.status,
        p_priority: updates.priority,
        p_order_index: updates.order_index,
        p_need_help: updates.need_help,
        p_help_message: updates.help_message,
        p_creator_id: null
      });

      if (error) throw error;
      const result = data as any;
      if (!result || !result.success) {
        if (result && result.message === 'Version conflict detected') {
          throw new Error('ÁõÆÊ®ôÂ∑≤Ë¢´ÂÖ∂‰ªñÁî®Êà∂‰øÆÊîπÔºåË´ãÈáçÊñ∞ËºâÂÖ•');
        }
        throw new Error(result?.message || 'Êõ¥Êñ∞ÁõÆÊ®ôÂ§±Êïó');
      }

      const { data: goalData, error: goalError } = await supabase
        .from('goals')
        .select('*')
        .eq('id', goalId)
        .single();
      if (goalError) throw goalError;
      
      set(state => ({
        goals: { ...state.goals, [goalId]: goalData }
      }));
      return goalData;
    } catch (error: any) {
      console.error('Êõ¥Êñ∞ÁõÆÊ®ôÂ§±Êïó:', error);
      set({ error: error.message || 'Êõ¥Êñ∞ÁõÆÊ®ôÂ§±Êïó' });
      throw error;
    }
  },

  /**
   * Âà™Èô§ÁõÆÊ®ôÔºàÊ≠∏Ê™îÔºâ
   */
  deleteGoal: async (goalId) => {
    try {
      const { error } = await supabase
        .from('goals')
        .update({ status: 'archived' })
        .eq('id', goalId);
      if (error) throw error;
      
      set(state => {
        const { [goalId]: deleted, ...remainingGoals } = state.goals;
        return { goals: remainingGoals };
      });
      console.log(`üìç deleteGoal - ÊàêÂäüÊ≠∏Ê™îÁõÆÊ®ô ${goalId}`);
      return true;
    } catch (error: any) {
      console.error('Ê≠∏Ê™îÁõÆÊ®ôÂ§±Êïó:', error);
      set({ error: error.message || 'Ê≠∏Ê™îÁõÆÊ®ôÂ§±Êïó' });
      return false;
    }
  },

  /**
   * ÈÇÑÂéüÊ≠∏Ê™îÁöÑÁõÆÊ®ô
   */
  restoreGoal: async (goalId: string) => {
    try {
      const { error } = await supabase
        .from('goals')
        .update({ status: 'todo' })
        .eq('id', goalId);

      if (error) throw error;

      set(state => {
        const existingGoal = state.goals[goalId];
        if (existingGoal) {
          return {
            goals: { ...state.goals, [goalId]: { ...existingGoal, status: 'todo' } }
          };
        }
        return state;
      });

      console.log(`üìç restoreGoal - ÊàêÂäüÈÇÑÂéüÁõÆÊ®ô ${goalId}`);
      return true;
    } catch (error: any) {
      console.error('ÈÇÑÂéüÁõÆÊ®ôÂ§±Êïó:', error);
      set({ error: error.message || 'ÈÇÑÂéüÁõÆÊ®ôÂ§±Êïó' });
      return false;
    }
  },

  /**
   * Êõ¥Êñ∞ÁõÆÊ®ôÊ±ÇÂä©Ë®äÊÅØ
   */
  updateGoalHelp: async (goalId: string, needHelp: boolean, helpMessage?: string) => {
    try {
      const existingGoal = get().goals[goalId];
      if (!existingGoal) return false;

      const updateData: Partial<Goal> = {
        need_help: needHelp
      };
      if (needHelp && helpMessage) {
        updateData.help_message = helpMessage;
      } else if (!needHelp) {
        updateData.help_message = undefined;
      }
      
      const result = await get().updateGoal(goalId, existingGoal.version, updateData);
      return !!result;
    } catch (error: any) {
      console.error('Êõ¥Êñ∞ÁõÆÊ®ôÊ±ÇÂä©Ë®äÊÅØÂ§±Êïó:', error);
      return false;
    }
  },

  /**
   * Êõ¥Êñ∞ Goal ÂèÉËÄÉË≥áË®ä
   */
  updateGoalReferenceInfo: async (goalId, referenceInfo) => {
    try {
      const { error } = await supabase
        .from('goals')
        .update({ reference_info: referenceInfo })
        .eq('id', goalId);
      if (error) throw error;
      
      set(state => {
        const existingGoal = state.goals[goalId];
        if (existingGoal) {
          return {
            goals: { ...state.goals, [goalId]: { ...existingGoal, reference_info: referenceInfo } }
          };
        }
        return state;
      });
      return true;
    } catch (error: any) {
      console.error('Êõ¥Êñ∞ Goal ÂèÉËÄÉË≥áË®äÂ§±Êïó:', error);
      set({ error: error.message || 'Êõ¥Êñ∞ Goal ÂèÉËÄÉË≥áË®äÂ§±Êïó' });
      return false;
    }
  },

  /**
   * Êñ∞Â¢û Goal ÈôÑ‰ª∂
   */
  addGoalAttachment: async (goalId, attachment) => {
    const state = get();
    const targetGoal = state.goals[goalId];
    if (!targetGoal) return false;
    const newAttachment: ReferenceAttachment = {
      ...attachment,
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      created_at: new Date().toISOString()
    };
    const currentReferenceInfo = targetGoal.reference_info || { attachments: [], links: [] };
    const updatedReferenceInfo = {
      ...currentReferenceInfo,
      attachments: [...currentReferenceInfo.attachments, newAttachment]
    };
    return await get().updateGoalReferenceInfo(goalId, updatedReferenceInfo);
  },

  /**
   * ÁßªÈô§ Goal ÈôÑ‰ª∂
   */
  removeGoalAttachment: async (goalId, attachmentId) => {
    const state = get();
    const targetGoal = state.goals[goalId];
    if (!targetGoal || !targetGoal.reference_info) return false;
    const updatedReferenceInfo = {
      ...targetGoal.reference_info,
      attachments: targetGoal.reference_info.attachments.filter(a => a.id !== attachmentId)
    };
    return await get().updateGoalReferenceInfo(goalId, updatedReferenceInfo);
  },

  /**
   * Êñ∞Â¢û Goal ÈÄ£Áµê
   */
  addGoalLink: async (goalId, link) => {
    const state = get();
    const targetGoal = state.goals[goalId];
    if (!targetGoal) return false;
    const newLink: ReferenceLink = {
      ...link,
      id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
      created_at: new Date().toISOString()
    };
    const currentReferenceInfo = targetGoal.reference_info || { attachments: [], links: [] };
    const updatedReferenceInfo = {
      ...currentReferenceInfo,
      links: [...currentReferenceInfo.links, newLink]
    };
    return await get().updateGoalReferenceInfo(goalId, updatedReferenceInfo);
  },

  /**
   * ÁßªÈô§ Goal ÈÄ£Áµê
   */
  removeGoalLink: async (goalId, linkId) => {
    const state = get();
    const targetGoal = state.goals[goalId];
    if (!targetGoal || !targetGoal.reference_info) return false;
    const updatedReferenceInfo = {
      ...targetGoal.reference_info,
      links: targetGoal.reference_info.links.filter(l => l.id !== linkId)
    };
    return await get().updateGoalReferenceInfo(goalId, updatedReferenceInfo);
  },

  /**
   * Ë®≠ÂÆöÁõÆÊ®ôË≤†Ë≤¨‰∫∫
   */
  setGoalOwner: async (goalId, userId) => {
    try {
      const { data: updatedGoal, error } = await supabase
        .from('goals')
        .update({ owner_id: userId })
        .eq('id', goalId)
        .select()
        .single();
      if (error) {
        console.error('Ë®≠ÁΩÆÁõÆÊ®ôË≤†Ë≤¨‰∫∫Â§±Êïó:', error);
        return null;
      }
      
      set(state => {
        const existingGoal = state.goals[goalId];
        if (existingGoal) {
          return {
            goals: { ...state.goals, [goalId]: { ...existingGoal, owner_id: userId } }
          };
        }
        return state;
      });
      console.log(`üìç setGoalOwner - ÊàêÂäüË®≠ÁΩÆÁõÆÊ®ô ${goalId} Ë≤†Ë≤¨‰∫∫ÁÇ∫ ${userId}`);
      return updatedGoal as Goal;
    } catch (error: any) {
      console.error('Ë®≠ÂÆöÁõÆÊ®ôË≤†Ë≤¨‰∫∫Â§±Êïó:', error);
      return null;
    }
  },

  /**
   * Ê∑ªÂä†ÁõÆÊ®ôÂçî‰ΩúËÄÖ
   */
  addGoalCollaborator: async (goalId, userId) => {
    try {
      const { data: currentGoal, error: getError } = await supabase
        .from('goals')
        .select('collaborator_ids')
        .eq('id', goalId)
        .single();
      if (getError) {
        console.error('Áç≤ÂèñÁõÆÊ®ôÂçî‰ΩúËÄÖÂ§±Êïó:', getError);
        return false;
      }
      const currentCollaborators = currentGoal.collaborator_ids || [];
      if (currentCollaborators.includes(userId)) {
        console.log(`Áî®Êà∂ ${userId} Â∑≤ÊòØÁõÆÊ®ô ${goalId} ÁöÑÂçî‰ΩúËÄÖ`);
        return true;
      }
      const updatedCollaborators = [...currentCollaborators, userId];
      const { error: updateError } = await supabase
        .from('goals')
        .update({ collaborator_ids: updatedCollaborators })
        .eq('id', goalId);
      if (updateError) {
        console.error('Êõ¥Êñ∞ÁõÆÊ®ôÂçî‰ΩúËÄÖÂ§±Êïó:', updateError);
        return false;
      }
      
      set(state => {
        const existingGoal = state.goals[goalId];
        if (existingGoal) {
          return {
            goals: { ...state.goals, [goalId]: { ...existingGoal, collaborator_ids: updatedCollaborators } }
          };
        }
        return state;
      });
      console.log(`üìç addGoalCollaborator - ÊàêÂäüÊ∑ªÂä†Âçî‰ΩúËÄÖ ${userId} Âà∞ÁõÆÊ®ô ${goalId}`);
      return true;
    } catch (error: any) {
      console.error('Ê∑ªÂä†ÁõÆÊ®ôÂçî‰ΩúËÄÖÂ§±Êïó:', error);
      return false;
    }
  },

  /**
   * ÁßªÈô§ÁõÆÊ®ôÂçî‰ΩúËÄÖ
   */
  removeGoalCollaborator: async (goalId, userId) => {
    try {
      // ÂÖàÊü•ÁèæÊúâÂçî‰ΩúËÄÖ
      const { data: currentGoal, error: getError } = await supabase
        .from('goals')
        .select('collaborator_ids')
        .eq('id', goalId)
        .single();
      if (getError) {
        console.error('Áç≤ÂèñÁõÆÊ®ôÂçî‰ΩúËÄÖÂ§±Êïó:', getError);
        return false;
      }
      const currentCollaborators = currentGoal.collaborator_ids || [];
      if (!currentCollaborators.includes(userId)) {
        console.log(`Áî®Êà∂ ${userId} Êú¨‰æÜÂ∞±‰∏çÊòØÁõÆÊ®ô ${goalId} ÁöÑÂçî‰ΩúËÄÖ`);
        return true;
      }
      const updatedCollaborators = currentCollaborators.filter((id: string) => id !== userId);
      const { error: updateError } = await supabase
        .from('goals')
        .update({ collaborator_ids: updatedCollaborators })
        .eq('id', goalId);
      if (updateError) {
        console.error('Êõ¥Êñ∞ÁõÆÊ®ôÂçî‰ΩúËÄÖÂ§±Êïó:', updateError);
        return false;
      }
      
      set(state => {
        const existingGoal = state.goals[goalId];
        if (existingGoal) {
          return {
            goals: { ...state.goals, [goalId]: { ...existingGoal, collaborator_ids: updatedCollaborators } }
          };
        }
        return state;
      });
      console.log(`üìç removeGoalCollaborator - ÊàêÂäüÁßªÈô§Âçî‰ΩúËÄÖ ${userId} ÂæûÁõÆÊ®ô ${goalId}`);
      return true;
    } catch (error: any) {
      console.error('ÁßªÈô§ÁõÆÊ®ôÂçî‰ΩúËÄÖÂ§±Êïó:', error);
      return false;
    }
  },
}));
